Link to the repository
https://github.com/ankaleh/cybersecurityproject

Installation instructions 
You need Python and Django libraries installed on your computer (see Cyber Security Base 2020 course's installation guide: https://cybersecuritybase.mooc.fi/installation-guide).

0) Open the command prompt.
1) Go to the directory where you want to clone the repository.
2) Clone the repository:
git clone https://github.com/ankaleh/cybersecurityproject
3) Go to the repository cybersecurity, where you should see manage.py file.
4) Run the application:
python3 manage.py runserver
5) Two users are already registered on the website. You can sign in (path /pages/signin/)  as Donald Duck (email: donald.duck@duckburg.burg, password: donald) or as Fethry Duck (email: fethry.duck@duckburg.burg, password: fethry) or you can create a new user on the path /pages/signup/. 

FLAW 1) Security Misconfiguration: 
Includes a wide range of issues from insecure configurations and outdated software libraries to very poor passwords. 

Description of flaw 1
Cottage application's admin username is "admin" and password is "cottages" that is very poor combination. Furthermore, the application saves user's passwords without encryption and salt.

How to fix it
Admin username and password should be changed into stronger ones and the application could use Django authentication systems (see flaw 2).

FLAW 2) Broken Authentication: 
Application's authentication and session management are often implemented incorrectly allowing attackers to compromise passwords, keys, or session tokens, or to exploit other implementation flaws to impersonate other users.

Description of flaw 2
Cottage application's authentication and authorization systems are unsafe. The application stores for example the users' passwords in plain-text format. It doesn't use Django authentication system that would protect against many of the threats related to authentication.

Furthermore, the application has a predictable sessionid generation instead of using random sessionid cookies created by Django that enables session hijacks.

How to fix it
The application could use Django authentication system that provides both authentication and authorization features, e.g. User objects with hashed password field and login function that saves the user’s ID in the session using Django’s session framework, logout function,  login_required() decorator etc. 

FLAW 3) Cross-Site-Scripting (XSS): 
XSS flaws make it possible to execute malicious content on the machine of another user. The threat is related for example to session hijacking, defacing web sites and redirecting the user to malicious sites. 

Description of flaw 3
Cottage application doesn't validate any inputs. In addition, it has a review feature that allows user send a review via form that is implemented incorrectly. The form uses Django's safe template tag that marks a string as not requiring further HTML escaping prior to output. That enables an attacker to send malicious scripts to the server. In addition, the application saves the reviews in the database and all of them end up on users' browsers.

Message function doesn't check if the user is authenticated. There are vulnerabilities related to access control, too (see flaw 4), so whoever surfing the Internet is able to send a message. 

How to fix it
Safe tag should be removed. All input should be validated . All forms should use POST request with Django's CSRF template tag instead of GET request.

FLAW 4) 
Broken Access Control: 
Web application does not restrict on what authenticated users are allowed to do. So, authenticated user may access for example other users' accounts and even modify other users' data or change access rights.

Description of flaw 4
Cottage application allows authenticated users to access to other users' myreservations page. User is able to do that by only changing the id number in url. Id numbers are auto-incremented primary keys generated by Django that makes it very easy to find out other users' id numbers. After accessing to other users' page attacker is able to remove other's reservations, because the cancel function only checks that someone is authenticated but it fails to verify that the user has the required credentials for the action, e.g. it doesn't check if the reservation's customer is the same person that is set in request.session[person] (the same who is trying to cancel the reservation).

How to fix it
The best protection against broken access vulnerabilities would be to use Django's authentication and authorization features. 

However, the code below should prevent access to other users' page. It reads the session attribute and checks if the request.session[person] (value set in login function) has the right value, i.e. it is the same as the value of person_id that is in the url path:

def myReservationsView(request, person_id): 
	person = Person.objects.get(id=person_id)
	personId = request.session['person'] #value set in login function
	if personId != person_id: 
		return HttpResponse("No rights!")

Further, the code below should prevent that user can not cancel reservations on other users' behalf. It checks if the person in request.session[person] is the same that in the reservation: 

def cancel(request, reservation_id):

#code

personId = request.session['person']
person = Person.objects.get(id=personId)
if reservation.person != person:
	return HttpResponse("No rights!")
else: 
	#code

reservation.delete()
return HttpResponse("Thank you! Your reservation is cancelled.")

In addition, it would be safer if id numbers were not auto-incremented integers.  In Django it is possible to specify a custom primary key that could be more arbitrary than automatically generated keys.

Even if broken access controll allows authenticated user view other users' page and remove their reservations he is not directly able to make reservation on other users' behalf because the application gets customer of a new reservation on the basis of the value of  request.session['person'] that is set in login function. It is still possible indirectly for example via XXS (see flaw 3, the review feature).

The application should use POST request method instead of GET request method in the booking form because GET request method is more vulnerable.  The Django's CSRF template tag, that is mandatory with POST requests in Django, protects against Cross Site Request Forgeries. (Still, the application makes it possible to steal the tag via review feature, see flaw 3).

FLAW 5)
Sensitive Data Exposure: Web application does not properly protect sensitive data, such as personally identifiable information. This kind of information should not be saved in database without encryption and other protection and requires special precautions when exchanged with the browser. 

Description of flaw 5
The application asks customer's social security number for invoicing when the customer is confirming his reservation. Social security numbers are saved in database without encryption. 

In fact, using ssn to identify customer is against the recently given order by the finnish Data Protection Ombudsman. According to that, organisations and companies must not use social security numbers to identify their customers on invoices.

The company sends invoices via email, that increases the threat.

How to fix it
The feature should be removed. There is not at all need for using personal identity codes in this application. The application only saves ssn in the database and doesn't use it. 

Sources: 
"Django documentation", https://docs.djangoproject.com/en/3.1/.
"Top 10 Web Application Security Risks", https://owasp.org/www-project-top-ten/. The Open Web Application Security Project (OWASP).
"Personal identity codes not to be used on invoices", https://tietosuoja.fi/en/-/henkilotunnusta-ei-tule-kayttaa-laskuissa. Office Of The Data Protection Ombudsman 1.6.2020, read 8.12.2020.